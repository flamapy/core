# Workflow

Here, we will describe the workflow to be followed by project maintainers to keep a clean, legible and descriptive log of contributions and releases.

## Develop branch

Any pull request containing a contribution which will be accepted MUST be managed using [this](#editing-develop-requests).

All squashed commits MUST follow [Conventional Commits](https://www.conventionalcommits.org/) (CC).

When starting a new release's development, we should change manually the setup.py version, following [this](#versioning)
and create new commit in develop branch, follow the CC, example: "bump: create 1.1.0.dev0 version"

## Releases and master branch

When we want to create a release, we should merge the development commits to master and we need create a tag with the
version to upload:

```
git tag -a v1.1.0.dev0 -m "build: release 1.1.0.dev0"
git push --tags
```

Github Actions workflow detects new tags, create release with changelog in github and upload new package to pypi.
When we use development version with .devX in version, this is detected by github actions and we create prereleased
version.

## Editing requests

### Editing develop requests

#### Single atomic contributions

Any atomic contribution with no conflict should not be edited at all, and just be squashed and merged.

#### Contributions with conflicts

A conflict-fixing commit should be done by either the contributor or a maintainer. Once there are no conflicts, squash and merge the PR.

#### Non-atomic contributions

While non-atomic contributions are discouraged, if a single PR could better be separated into multiple commit messages, "git rebase -i" provides great functionality for this task.

As an example, for this set of commits:

```
A -> B -> C -> D -> E
```

If A and B were part of one feature, and C, D and E of a distinct one, this input would create two distinct squashed commits:

```
pick aaaaaaa Commit A
squash bbbbbbb Commit B
pick ccccccc Commit C
pick ddddddd Commit D
squash eeeeeee Commit E
```

If A and D were part of the same feature, we could reorder them:

```
pick aaaaaaa Commit A
squash ddddddd Commit D
pick bbbbbbb Commit B
pick ccccccc Commit C
squash eeeeeee Commit E
```


After having all multiple squashed and correctly named commits, we MUST be COMPLETELY SURE there are NO CONFLICTS between the request and develop branch, and then rebase (not squash) the request.

### Editing master (release) requests

If any release commit is detected to not follow CC, they can be edited by "git rebase -i" using the "reword" option for the commits to be edited.

## Versioning

We work with Semantic Versioning and development release, for more information [PEP-440](https://peps.python.org/pep-0440/). If our next version is v1.1.0,
the development version will v1.1.0.dev0, and we increase the development version as many times as we need.
When finish with development version, and our version is stable, we use v1.1.0.

We create development version for avoid use pypi test, is more practical.
